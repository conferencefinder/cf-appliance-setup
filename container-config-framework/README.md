# Container Configuration Framework (CCF)

The **Container Configuration Framework** (**CCF**) is an opionated approach to generating container 
configuration files that can then be loaded into Docker, AWS ECR/ECS, and other engines.

CCF uses [Jsonnet](https://jsonnet.org/) as the core configuration language and generates appropriate
Dockerfile, docker-compose.yml, and related artifacts.

Prerequisites:

* Linux server, tested only on Ubuntun 18.04
* user with sudo privileges and Docker permissions
* GNU Make, git, curl, wget, Jsonnet, jq, Docker, Docker Compose, osQuery

Useful environment variables during installation:

Set **CCF_HOME** to where the CCF should be installed, defaults to /opt/container-config-framework. If you
set this to something other than the default, you must make sure it's set whenever the Makefile is called, 
too because all CCF binaries and libs use the variable to indicate the installation location.

## How to Install the CCF

Intial setup in default location:

    curl https://raw.githubusercontent.com/shah/container-config-framework/master/bin/setup-CCF.sh | bash

Intial setup in another location (e.g. /etc/CCF):

    export CCF_HOME=/etc/CCF
    curl https://raw.githubusercontent.com/shah/container-config-framework/master/bin/setup-CCF.sh | bash

## How to Upgrade the CCF

The directory where CCF is installed is considered read-only. Any configuration files you add should be 
placed outside of the installation directory. The **JSONNET_PATH**, **CCF_FACTS_FILES**, and other variables 
can be used to override configuration files so that your files instead of the defaults are used. 

Therefore, to upgrade you just:

    sudo rm -rf /opt/container-config-framework
    curl https://raw.githubusercontent.com/shah/container-config-framework/master/bin/setup-CCF.sh | bash

## Checking Dependencies

CCF has some important dependencies. After installation, you should run:

    cd /opt/container-config-framework/lib
    make check-dependencies

## Conventions

CCF manages containers using git, make, and [Jsonnet](https://jsonnet.org/). All developers looking
to extend CCF need to know those tools very well. The framework manages containers by an *opinionated* set 
of *conventions*:

Each container is defined by files in a *container definition home* ("CDH") directory. The CDH can be placed
anywhere but follows these conventions:

* The *name* of the **CDH** directory is assumed to be the container name.
* Each **CDH** directory contains, at a minium, a container.ccf-defn.jsonnet config file.
* Each **CDH** directory contains a .gitignore file which is auto-generated by the Makefile
  and makes sure that no git tracking occurs for files generated by Jsonnet.
* The CDH directory's Makefile feeds Jsonnet a container.ccf-defn.jsonnet and generates all necessary
  assets / artifacts.

## Scripts

* **CCF_HOME/bin/ccfmake** is a convenience script to run the Makefile in a **CDH** if CCF_HOME/lib/Makefile 
  is not symlink'd. This script is symlink'd as /usr/bin/ccfmake by the installer.
* **CCF_HOME/bin/ccfinit** is a convenience script to download container definition files from a common repo.
  This script is symlink'd as /usr/bin/ccfinit by the installer.

## Environment Variables

These are the most useful environment variables to set before calling the Makefile, all of them have
sensible defaults:

* **JSONNET_PATH** is a colon-separated path which indicates where Jsonnet configs should be searched.
* **CCF_HOME** is where the CCF is installed (default is /opt/container-config-framework).
* **CCF_LOG_LEVEL** should be set to INFO to see verbose messages as CCF does its job (default is NONE).
* **CCF_FACTS_FILES** is where CCF stores fact files - see "Facts Generator" section below for explanation.

## Container Makefile

Each container definition home ("CDH") directory may contain a Makefile which is, usually, symlink'd to
CCF_HOME/lib/Makefile. This allows each container to have it's own Makefile but conveniently
links to a master Makefile unless the container has something special.

If the CDH does not contain a Makefile, then the **ccfmake** convenience script may be used as a replacement.

The Makefile has a simple plugin model:

* If a file named **before_configure.make-plugin.sh** exists in the container definition home directory,
  it is run right before the Makefile's configure target (*before* generating all artifacts).
* If a file named **after_configure.make-plugin.sh** exists in the container definition home directory,
  it is run right after the Makefile's configure target (*after* generating all artifacts). Unlike the
  **before_configure.make-plugin.sh**, which must already exist before the code generator process starts, the
  **after_configure.make-plugin.sh** can be generated by Jsonnet's processing of container.ccf-defn.jsonnet.
* If a file named **container.make.inc** exists in the container definition home directory, it is
  included in the Makefile -- effectively allowing you to add targets. You can also redefine targets
  but you'll get a warning. The **container.make.inc** may be generated as part of the code generation process.
* If a file named **after_start.make-plugin.sh** exists in the container definition home directory, it
  is run immediately after the *make start* target concludes. This allows you to run some post-start
  functionality like checking the health of a container or ensuring other dependencies are executed.
  The **after_start.make-plugin.sh** script can be generated by Jsonnet's processing of 
  container.ccf-defn.jsonnet.

The Makefile has these typical targets:

* **help** shows all the targets available in the Makefile -- use that instead of this document when possible
* **check-dependencies** evaluates the runtime environment to see if there's anything missing
* **build** builds the container using Dockerfile in this directory (if no Dockerfile, this target is ignored)
* **configure** generates the container's artifacts (driven by container.ccf-defn.jsonnet), then runs the
  **after_configure.make-plugin.sh** shell script (if it exists)
* **start** runs configure, then starts the container and all dependencies
* **inspect** inspects a running container's settings, volumes, etc.
* **logs** shows the logs in the container
* **ports** shows the container's mapped ports
* **stop** stops the container but retain volumes and generated files
* **kill** stops the container and **DESTRUCTIVELY** removes networks, volumes, etc. but leaves generated files
* **clean** stops the container and **DESTRUCTIVELY** cleans up generated files, networks, volumes, etc.

The Makefile can also have other containter-specific targets using the **container.make.inc** feature.

In addition to the files created by Jsonnet processing of container.ccf-defn.jsonnet, the Makefile generates 
these housekeeping files:

* **.ccf_container.ccf-defn.jsonnet_generated**, a text file that contains the list of files generated
* **.ccf_delete_generated_files.sh**, which is executed by the **clean** target
* **.ccf_facts** directory, which contains generated facts (see below)
* **.gitignore**, to make sure generated files are not tracked or committed (in case the container is git-managed)

## Facts Generator

Before the container.ccf-defn.jsonnet file is interpreted, there are a series of "facts generator" scripts that
can be run to pre-populate configuration entries from the environment. Facts can be retrieved from osquery, from
the environment, or as arbitrary shell scripts snippets.

The Makefile uses this script by default, but it can be overridden:

    CCF_FACTS_GENERATOR_SCRIPT ?= $(CCF_HOME)/bin/generate-facts.sh

Here's an example of the default $(CCF_HOME)/etc/facts-generator.ccf-conf.jsonnet configuration file:

    {
        osQueries: {
            singleRow : [
                { name: "system-localhost", query: "select * from system_info" }
                { name: "eth0-interface-localhost", query: "select * from interface_addresses where interface = 'eth0'" }
            ],
            multipleRows : [
                { name: "interfaces-localhost", query: "select * from interface_addresses" }
            ],
        },

        shellEvals: [
            { name: "docker-localhost", key: "dockerHostIPAddress", evalAsTextValue: "/sbin/ip -4 -o addr show dev eth0| awk '{split(\\$4,a,\\\"/\\\");print a[1]}'" },
            { name: "docker-localhost", key: "dockerBridgeNetworkGatewayIPAddress", evalAsTextValue: "docker network inspect --format='{{range .IPAM.Config}}{{.Gateway}}{{end}}' bridge" },
        ],
    }

You can pass one or more facts generator files, colon-separated, via the CCF_FACTS_FILES environment variable.
The default value in the Makefile calls these source files, in this order:

    $(CCF_HOME)/etc/common.ccf-factsgen.jsonnet
    $(CONTAINER_DEFN_HOME)/container.ccf-factsgen.jsonnet

## Configuration Files

CCF generates Dockerfile, docker-compose.yml, and a variety of other configuration files using Makefiles
and the [Jsonnet data templating language](https://jsonnet.org/). When Jsonnet runs, it uses the 
JSONNET_PATH Makefile variable defined in CCF_HOME/lib/Makefile, but it can be overridden.

The default path is as follows, the earlier path in the list wins:

    $(HOME)/.ccf/secrets
    $(HOME)/.ccf/etc
    $(CCF_HOME)/lib
    $(CCF_HOME)/etc
